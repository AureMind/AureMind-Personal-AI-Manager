{% extends "notes/base.html" %}
{% load static %}

{% block title %}AI Chat{% endblock %}

{% block content %}
<h2 class="mb-2">AI Chat</h2>
<p class="text-muted small mb-4">Your conversation is temporary. Click "Save" on any response. You can (optionally) select a note to provide as context for your prompt.</p>

<div id="chat-container">
  <div id="chat-history">
    
    {# Initial welcome message: now rendered cleanly without the "box" #}
    <div class="chat-cell output-cell">
        <div class="output-cell-content">Hello! How can I help you today?</div>
    </div>
    
  </div>
  
  <form id="chat-form">
    {% csrf_token %}
    
    {# Floating pill container structure #}
    <div class="floating-input-wrapper">
      
      {# Input and Select fields moved inside the wrapper #}
      <div id="prompt-container">
        <textarea id="chat-prompt" class="form-control" rows="1" placeholder="Type your prompt here..."></textarea>
        <select id="note-select" class="form-select flex-grow-0">
          <option value="">No note context</option>
          {% for note in all_notes %}
            <option value="{{ note.pk }}">{{ note.title|truncatewords:5 }}</option>
          {% endfor %}
        </select>
      </div>

      {# Controls container for Send Button only - SPINNER REMOVED #}
      <div id="controls-container">
        <button type="submit" class="btn btn-primary">Send</button>
      </div>
      
    </div>
  </form>
</div>

{% endblock %}

{% block extra_js %}
<script>
// --- Dynamic Resizing for Textarea (Essential for modern chat look) ---
function autoResizeTextarea(textarea) {
    if (!textarea) return;
    textarea.style.height = 'auto'; // Reset height
    textarea.style.height = (textarea.scrollHeight) + 'px'; // Set to scroll height
}

document.addEventListener('DOMContentLoaded', function() {
    const promptInput = document.getElementById('chat-prompt');
    const noteSelect = document.getElementById('note-select');
    const chatHistory = document.getElementById('chat-history');
    const chatForm = document.getElementById('chat-form');
    
    // Initial resize for existing content (should be minimal)
    autoResizeTextarea(promptInput);
    promptInput.addEventListener('input', () => autoResizeTextarea(promptInput));


    // --- Handle Enter/Shift+Enter for sending ---
    promptInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            chatForm.querySelector('button[type="submit"]').click();
        }
    });

    // --- Handle form submission ---
    chatForm.addEventListener('submit', async function(e) {
        e.preventDefault();

        const submitButton = this.querySelector('button[type="submit"]');
        const promptText = promptInput.value.trim();
        const selectedNoteId = noteSelect.value;
        const selectedNoteText = noteSelect.options[noteSelect.selectedIndex].text;

        if (!promptText) return;

        // --- Show user's prompt ---
        const inputCell = document.createElement('div');
        inputCell.className = 'chat-cell input-cell';
        let promptDisplay = promptText;
        if (selectedNoteId) {
            promptDisplay = `[Context: ${selectedNoteText}] \n${promptText}`;
        }
        inputCell.textContent = promptDisplay;
        chatHistory.appendChild(inputCell);
        
        // --- Disable form and reset input ---
        promptInput.value = '';
        autoResizeTextarea(promptInput); // Reset textarea height
        promptInput.disabled = true;
        noteSelect.disabled = true;
        submitButton.disabled = true;
        
        // Auto-scroll to bottom immediately after input submission
        chatHistory.scrollTop = chatHistory.scrollHeight;

        try {
            const response = await fetch("{% url 'notes:chat' %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify({ 
                    prompt: promptText,
                    note_id: selectedNoteId
                })
            });
            const data = await response.json();

            // --- Create and display AI's response cell ---
            const outputCell = document.createElement('div');
            outputCell.className = 'chat-cell output-cell';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'output-cell-content';
            
            let aiResponseText_HTML = '';
            let aiResponseText_RAW = ''; 

            if (data.response) {
                aiResponseText_HTML = data.response;
                aiResponseText_RAW = data.raw_response;
            } else if (data.error) {
                aiResponseText_HTML = 'Error: ' + data.error;
                aiResponseText_RAW = 'Error: ' + data.error;
                contentDiv.style.color = 'red';
            }
            
            contentDiv.innerHTML = aiResponseText_HTML;
            outputCell.appendChild(contentDiv);

            // --- Create and add the Save button (if no error) ---
            if (data.response) {
                const saveButton = document.createElement('button');
                saveButton.textContent = 'Save';
                saveButton.className = 'btn btn-sm btn-outline-secondary save-btn';
                
                saveButton.addEventListener('click', async function() {
                    this.textContent = 'Saving...';
                    this.disabled = true;

                    try {
                        const saveResponse = await fetch("{% url 'notes:save_chat' %}", {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': '{{ csrf_token }}'
                            },
                            body: JSON.stringify({
                                prompt: promptDisplay,
                                ai_response: aiResponseText_RAW
                            })
                        });
                        const saveData = await saveResponse.json();
                        
                        if (saveData.status === 'success') {
                            this.textContent = 'Saved!';
                            this.classList.remove('btn-outline-secondary');
                            this.classList.add('btn-success');
                        } else {
                            this.textContent = 'Error!';
                            this.classList.add('btn-danger');
                        }
                    } catch (err) {
                        this.textContent = 'Failed!';
                        this.disabled = false;
                    }
                });
                outputCell.appendChild(saveButton);
            }

            chatHistory.appendChild(outputCell);

        } catch (error) {
            const outputCell = document.createElement('div');
            outputCell.className = 'chat-cell output-cell';
            outputCell.textContent = 'Error: Could not connect to the server.';
            outputCell.style.color = 'red';
            chatHistory.appendChild(outputCell);
        } finally {
            // --- Re-enable form ---
            promptInput.disabled = false;
            noteSelect.disabled = false;
            submitButton.disabled = false;
            
            // Final auto-scroll
            chatHistory.scrollTop = chatHistory.scrollHeight;
            
            // Auto-resize input and focus
            autoResizeTextarea(promptInput);
            promptInput.focus();
        }
    });
});
</script>
{% endblock extra_js %}